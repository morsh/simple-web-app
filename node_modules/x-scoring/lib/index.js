
var async = require('async');
var request = require('request')
var config = require('x-config');
var path = require('path');
var tedious = require('tedious');
var queue = require('x-queue');
var db = require('x-db');
var constants = require('x-constants');

var APP_NAME = 'scorer';

function run(cb) {
  cb = cb || Function;

  var queueConfig = {
    storageName: config.storage.account,
    storageKey: config.storage.key,
    queueName: config.queues.scoring,
    checkFrequency: 5000
  };

  var queueIn = queue(queueConfig);
  queueIn.init(function (err) {
    if (err) return cb(err);
    console.log('start processing scoring queue');
    checkQueue();
  });

  
  /* 
  queue item sample:
  
  {"requestType":"score","data":{"sourceId":2,"docId":"2000354","sentenceIndex":129,"sentence":"Similarly, an examination of the deep sequencing data depicted in Table S1 in the report by Ruby and coworkers  also shows that miR-84 has 3 main variations.","mentions":[{"id":"3038","type":"gene","value":"has 3"},{"id":"1128","type":"gene","value":"miR"},{"id":"5719","type":"gene","value":"S1"},{"id":"6267","type":"gene","value":"S1"},{"id":"6205","type":"gene","value":"S1"},{"id":"8241","type":"gene","value":"S1"},{"id":"5707","type":"gene","value":"S1"},{"id":"79187","type":"gene","value":"miR"},{"id":"406904","type":"gene","value":"miR"},{"id":"220972","type":"gene","value":"miR"},{"id":"29116","type":"gene","value":"miR"},{"id":"83856","type":"gene","value":"miR"},{"id":"22877","type":"gene","value":"miR"},{"type":"miRNA","value":{"mirna":"hsa-mir-84","origin":"miR-84"}}]}}
  */

  function checkQueue() {
    console.log('checking queue...');
    queueIn.getSingleMessage(function (err, message) {
      if (err) {
        console.error('error getting message from queue', err);
        return setNextCheck();
      }

      if (!message) {
        return setNextCheck();
      }

      return processMessage(message, function (err) {
        if (err) console.error('error processing message:', message.messageid, err);
        
        // move to the next message
        return checkQueue();
      });
    });
  }

  function setNextCheck() {
    setTimeout(checkQueue, queueConfig.checkFrequency);
  };

  function processMessage(message, cb) {
    console.log('new sentence', message);

    var msgObject;
    try {
      msgObject = JSON.parse(message.messagetext);
    }
    catch (err) {
      console.error('error parsing message, invalid json, deleting...', message);
      return deleteMessage(message);
    }

    var data = msgObject.data && msgObject.data;
    if (!data) {
      console.error('message does not contain data field, deleting...', message);
      return deleteMessage(message);
    }

    if (msgObject.requestType == constants.queues.action.LAST_ITEM_TO_SCORE) {
      
        // update document status to Processed
        return db.updateDocumentStatus({
            sourceId: data.sourceId,
            docId: data.docId,
            statusId: constants.documentStatus.PROCESSED
          },
          function (err) { 
            if (err)  return cb(err);
          
            // delete message from queue
            return queueIn.deleteMessage(message, function (err) {
              if (err) return cb(err);
              console.info('item deleted from queue');
              return cb();
            });
        });
    }

    if (msgObject.requestType !== constants.queues.action.SCORE) {
      console.error('message should not appear in this queue, deleting...', message);
      return deleteMessage(message);
    }

    return getScoring(data, function (err, result) {
      // if we had an error getting the scoring for the message,
      // we'll return and hopefully the message will be scored the next
      // time we try...
      if (err) {
        console.error('error getting scoring for message', err);
        return cb(err);
      }

      console.log('got scoring relations', JSON.stringify(result));

      if (!result.relations || !result.relations.length) {
        console.error('scorer didn\'t return relations for sentence', data, result);

        // should we delete the message from the queue? 
        // should we leave it there for reprocessing?
        return deleteMessage(message);
      }

      data.entities = result.entities;
      data.relations = result.relations;
      
      // insert relations into db
      return db.upsertRelations(data, function (err) {
        
        // if we had an error inserting into db, we don't want to delete from the queue,
        // just return and hopefully the next iteration will work.
        // the item will stay in the queue until it will be processed.
        if (err) {
          console.error('error updating relation in db', err)
          return cb(err);
        }
        
        // item was processed and saved in db successfully- delete from queue
        return deleteMessage(message, cb);
      });
    });

    function deleteMessage(message) {
      return queueIn.deleteMessage(message, function (err) {
        if (err) return cb(new Error('error deleting item from queue', err));
        console.log('item deleted from queue', message.messageid);
        return cb();
      });
    }
  };


  function getScoring(data, cb) {
    
    var finalEntities = [];
    var finalRelations = [];
    
    var entitiesHash = {};
    var relationsHash = {};
    
    async.each(config.services.scoring,
      function (scoringService, cb) {

        var opts = {
          url: scoringService.url,
          method: 'post',
          json: {
            text: data.sentence,
            entities: data.mentions
          }
        };
        
        console.log('requesting scoring', JSON.stringify(opts));
        
        return request(opts, function (err, resp, body) {
          console.log('body', JSON.stringify(body));
          
          if (err) return cb(err);
          if (resp.statusCode !== 200) return cb(new Error('error: statusCode=' + resp.statusCode));
          
          var relations = body && body.relations || [];
          relations.forEach(function (relation) {
            
            var entities = relation.entities || []; 
            entities = entities.map(function (entity) {
              return {
                typeId: constants.conceptTypes[entity.type.toUpperCase()],
                id: entity.id || entity.value,
                name: entity.value
              }
            });
            
            entities.forEach(function (entity) {
              var key = entity.type + '~' + entity.id;
              if (!entitiesHash[key]) {
                entitiesHash[key] = 1;
                finalEntities.push(entity);
              }
            });
            
            // check that we have at least one mirna and one gene
            var genes = entities.filter(function (entity) {
              return entity.typeId === constants.conceptTypes.GENE ? entity : null;
            });

            var mirnas = entities.filter(function (entity) {
              return entity.typeId === constants.conceptTypes.MIRNA ? entity : null;
            });
            
            mirnas.forEach(function (mirna) {
              genes.forEach(function (gene) {
                var key = scoringService.id + '~' + mirna.id + '~' + gene.id;
                if (relationsHash[key]) return;
                relationsHash[key] = 1;
                finalRelations.push({
                  scoringServiceId: scoringService.id,
                  modelVersion: body.modelVersion,
                  entity1: mirna,
                  entity2: gene,
                  relation: relation.class || relation.classification,
                  score: relation.score
                });
              })
            });
          });
          return cb();
        });
      },
      function (err) {
        if (err) return cb(err);

        var result = { entities: finalEntities, relations: finalRelations };
        console.log('finished processing scoring for sentence: %j', result);
        return cb(null, result);
      }
    );
  }
}

module.exports = {
    run: run
}